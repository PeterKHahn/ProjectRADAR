_All ideas approved by Joe._

# s18-ahitt1-efu2-phahn1--ckim34
Team Name: Dream Team (!)
Group Members:
  - Anina Hitt (ahitt1)
    - Strengths: javascript. jquery. backend logic. html/css. ui/ux.
    - Weaknesses: AI. networking.
  - Claire Kim (ckim34)
    - Strengths: visual design and structure, css/html website design
    - Weaknesses: program logic and modeling, AI
  - Ellen Fu (efu2)
    - Strengths: visual design, full stack development, algorithms
    - Weaknesses: low-level programming, newest web technologies, networking
  - Peter Hahn (phahn1)
    - Strengths: AI and related data structures/techniques, modeling and logic abstraction
    - Weaknesses: super high-level programming, networking


## Choice One: Unnamed Radar Hunger Games Game
### Summary
Our team hopes to create a real-time, top-down multiplayer game that tests a player’s ability to strategically gather and consume resources in a king of the hill conflict against other players. As players collect resources, they will be better able to survive the rounds of the game and fight against other players. Although players may choose to remain isolated during the beginning phases of the game, it becomes much more difficult for players to avoid interacting with each other through the middle and late stages of the game.
Although the objective of the game is to be the last one standing in the arena, the secondary objective of the game is to find the resource jackpot by strategically placing Radars around the map. Although the resource jackpot does not guarantee a victory, it makes it significantly easier to do so, and neglecting to search for it will usually end in defeat.
This is our first choice project, and one we have all agreed upon, so if the project is not approved, we would like ideas to make it fit the requirements of the assignment.
Defining the Problem
As with any game, there are two problems that our team needs to address, that are related: Primarily, we want to create a game that is enjoyable to our target audience. To do this, we must balance our design to allow for a healthy learning curve, quick and interesting game mechanics, and friendly user interfaces. From a more technical standpoint, we must smooth the communication between multiple web client to our server, so that actions that a client wishes to perform are communicated quickly and effectively, and converted into game logic. Our Artificial Intelligent Players must be able to make smart decisions, likely using alpha-beta or A* searches, as well as possibly hidden markov models. The AI must be smart, without making it so smart that it detracts from the game.
The second concern is constructing a system that is free from exploitation from players. We must design the game in such a way that players cannot “gamify” the game to the point where they are avoiding the goals that we hope for them, including interacting with other players, making strategic decisions, and looking for goal states with their Radars.

### The Structure
We will address the challenges laid out above in our game design as well through our technical computer science experience. Without being too general, our project consists of five components, each with a purpose on solving one or more of the problems described above.
  - System Architecture: As our project grows, we will be handling multiple components. In addition to the game engine and logic, we have a front-end client, as well as potential for various interface inclusions such as a HUD and chat, which will involve separate components and maybe databases. Abstraction will be very important here, since there may be many parts integrated together. The organization of the architecture will be the most challenging portion of this architecture and will determine the ease of creating and testing our game.
  - Game Engine: The game engine will hold the logic of our problems, and is therefore where the majority of our game design decisions will end up. A good game engine and design allows for a healthy learning curve and an interesting game. It will be very important that we think through our game design, by carefully considering all the components of our game and making sure they promote the goals we established earlier in addition to making sure the game cannot be exploited to win without following our goals. This will be difficult, and will be the bulk of our testing against real users, since a solid game design will be the backbone of our project. In addition, we will use the abstraction techniques we have been developing in this class to make sure that it is easy to experiment, adjust, and adapt the way our game runs to best accomplish this task.
  - AI: The artificial intelligence portion takes our knowledge of intelligent machines and applies it as computer player in our game. The AI serves to make the game more challenging, as well as interesting. As mentioned above, the challenge will be to make our machine “intelligent”, using techniques such as A* search, computation, and Hidden Markov Models to determine what will pose the greatest threat to our non-AI players. Although each of these components on their own may be simple and algorithmic, the challenge will be to combine multiple techniques in AI to make sure that it will be a challenge to play against our  machine.
  - Networking: The quality of this portion of the project will determine whether or not our game can be enjoyable. Consumers of game love to complain about lag, so the communication between client input and server interpretation is crucial to improving the user-experience, while also serving as the framework between the logic of the game and the front-end. Because networking is new to many of us, learning to create solid networks in Java as well as testing and debugging the constraints of network programming will be the challenge in this portion of the project.
  - Front-End Design: The User interface in the front-end is what the player first sees and will be where our current team (before doing Maps) will need to learn the most about. Having a nice UI is important for any program, but it is especially important here since the purpose of our project is enjoyment and entertainment. Learning how to draw graphics in javascript, while also handling user inputs to send to the back-end will be a challenge that we look forward to solving.

## Choice Two: Schedulers for TAs
A scheduler that serves primarily as a tool for planning how TA’s are put into their respective work slots, taking into consideration the supply of TA’s time as well as the demand for certain time slots. For example, the day before a large project is due will have a greater demand than the day after one is due.

### Problem and Solution
The problem the scheduler faces is taking into account different TA/volunteer groups and prioritizing them. Of course the idea of a scheduler in and of itself is an algorithmic challenge, which can implemented naively at first, and then improved through research of faster methods. The design question however is much more interesting: Does the user determine the priority of each slot or does the system? If it’s the latter, then to what criteria? How can the project take account for small distinctions, such as the difference in priority of a homework being due and a midterm being released? We hope to design the project so that prioritization is a mix of both user and machine input. User’s can classify different “hot spots” of importance, specifying how important it is that hours near that time are filled. The machine can then use default settings to make a scheduler that seems to best fit the parameters of the user. If the user makes adjustments to the schedule, the machine can adapt in the future to better model the TA’s preferences.

### Components
  - Scheduler Logic: This part is critical in that it is the design for the logic and heuristics necessary to create the first schedule. This will tackle the main problem in the scheduling algorithm. The biggest challenge will be making sure that the algorithm is efficient, while also being a model for what TA’s actually need in the workplace.
  - Adjustment algorithm: Creating an “intelligent” design for the adjustment algorithm will take careful consideration as well as testing and interviewing users on what would be the best way to learn their preferences. As described above, this component is important in allowing for the system to better understand the prioritization preferences of the user. Although coding something like this won’t be very difficult technically, it will be a challenge taking into account all the variables that a TA might want from this system.
  - User Interface: It is important for TA’s to easily interact with the scheduler, to the point where it is easier to do it on this program than it is by hand on a spreadsheet. The user interface will accomplish this ease of access. The challenge here is learning about how to use javascript and html to represent spreadsheets that can easily be interacted with and can easily communicate with the backend.

## Choice Three: Books Books Books
A virtual library to enhance book lovers' reading experiences through book suggestion algorithms, books and notes storage, and encouraging readers to read more and share more reviews with gamification.

A large issue that book lovers may frequently run into is that they may lose track of which books they have read and how each book most impacted them at the time. These information are valuable for readers no matter if they are reading books for personal development, entertainment, or for research to prepare for papers.

### Primary features
  - Shelves: the "CRUD" aspect of the application where users can input the books they have read along with any notes and comments that they have written for the book. The notes will ideally support photo uploads of handwritten notes or PDF/text files of digital notes. Users will also be able to rate books they have read and add tags as they wish. The purpose of shelves is that users can organize their books as they wish (e.g. books for leisure and books for research papers).
    - This will also allow readers to input books that they have not yet read but are either hoping to read or in the process of reading. These will be taken into account in the recommendations component as well.
  - Book journal: This feature will be part of what goes into the shelves of this library -- if the user so wishes, this feature can give suggestions on how to keep a book journal and some useful questions to keep in mind while reading, no matter for leisure or for work. This is to encourage readers to gain the most they can and want from the books they read and be able to record their thoughts to reflect on later.
  - Recommendations: An algorithm that gives books recommendations based on the reviews that the user has given to books they have already read. If they have not inputted any books, it can give recommendations based on genres or general recommendations based on all-time popular books. This feature also allows users to recommend books to one another so that it is easier for friends (or strangers!) to share with one another.
  - Social/gamification: Readers will have a bookworm avatar that they can evolve (to a book-butterfly?) by gaining points through reading books, writing reviews, uploading notes for books, and giving good recommendations to others.
  - Front end/UI: Research will need to be done to see what would be most useful to readers. The most important goal of this project is to make a tool that will be constructive to all sorts of readers so the UI needs to be both clear and flexible for the features to be easily discoverable and learned but also personalizable for readers to create their own reading experience.
